

#include <stdlib.h>
#include <stdio.h>

#include "original.h"
#include "quantized.h"

#ifndef EQUIVALENCE
#define EQUIVALENCE 0
#endif

#ifndef EPSILON
#define EPSILON -1
#endif

#define BATCH 1

#ifndef WIDTH
#define WIDTH 64
#endif

#ifndef OUTPUT_SIZE
#define OUTPUT_SIZE 10
#endif

float nondet_float();

const float lower_bounds[BATCH][WIDTH] = 
{{0, 0, 0, 0.02921568788588047027587890625, 0.056666672229766845703125, 0.017450980842113494873046875, 0, 0, 0, 0, 0.166470587253570556640625, 0.593921601772308349609375, 0.4370588362216949462890625, 0.4370588362216949462890625, 0.10764706134796142578125, 0, 0, 0.048823527991771697998046875, 0.597843170166015625, 0.3664706051349639892578125, 0.0527451038360595703125, 0.3468627631664276123046875, 0.51156866550445556640625, 0.013529412448406219482421875, 0, 0.3154902160167694091796875, 0.59000003337860107421875, 0.033137254416942596435546875, 0, 0.080196082592010498046875, 0.601764738559722900390625, 0.095882356166839599609375, 0, 0.51156866550445556640625, 0.2998039424419403076171875, 0, 0.005686275660991668701171875, 0.3194117844104766845703125, 0.531176507472991943359375, 0.037058822810649871826171875, 0, 0.4841176569461822509765625, 0.4645098149776458740234375, 0.166470587253570556640625, 0.4292156994342803955078125, 0.640980422496795654296875, 0.17039215564727783203125, 0, 0, 0.131176471710205078125, 0.57431375980377197265625, 0.66843140125274658203125, 0.4292156994342803955078125, 0.088039219379425048828125, 0, 0, 0, 0, 0.02529411949217319488525390625, 0.0527451038360595703125, 0.001764706335961818695068359375, 0, 0, 0}};

const float upper_bounds[BATCH][WIDTH] = 
{{0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.04921568930149078369140625, 0.07666666805744171142578125, 0.0374509803950786590576171875, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.1864705979824066162109375, 0.613921582698822021484375, 0.4570588171482086181640625, 0.4570588171482086181640625, 0.12764705717563629150390625, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.06882353127002716064453125, 0.617843151092529296875, 0.3864705860614776611328125, 0.07274509966373443603515625, 0.3668627440929412841796875, 0.53156864643096923828125, 0.0335294120013713836669921875, 0.00999999977648258209228515625, 0.3354901969432830810546875, 0.61000001430511474609375, 0.05313725769519805908203125, 0.00999999977648258209228515625, 0.10019607841968536376953125, 0.621764719486236572265625, 0.11588235199451446533203125, 0.00999999977648258209228515625, 0.53156864643096923828125, 0.3198039233684539794921875, 0.00999999977648258209228515625, 0.0256862752139568328857421875, 0.3394117653369903564453125, 0.551176488399505615234375, 0.05705882608890533447265625, 0.00999999977648258209228515625, 0.504117667675018310546875, 0.4845097959041595458984375, 0.1864705979824066162109375, 0.4492156803607940673828125, 0.660980403423309326171875, 0.1903921663761138916015625, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.1511764824390411376953125, 0.59431374073028564453125, 0.68843138217926025390625, 0.4492156803607940673828125, 0.10803921520709991455078125, 0.01392156817018985748291015625, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.04529412090778350830078125, 0.07274509966373443603515625, 0.0217647068202495574951171875, 0.00999999977648258209228515625, 0.00999999977648258209228515625, 0.00999999977648258209228515625}};

static inline void init_symbolic_input(float input[BATCH * WIDTH])
{
    for(size_t i = 0; i < BATCH * WIDTH; i++)
    {
        input[i] = nondet_float();            
    }
}

static inline void add_input_assumptions(float input[BATCH * WIDTH], float x[BATCH][WIDTH])
{
    size_t i = 0;
    for(size_t b = 0; b < BATCH; b++)
    {
	    for(size_t w = 0; w < WIDTH; w++)
        {
            x[b][w] = input[i];
		    __ESBMC_assume(lower_bounds[b][w] <= x[b][w] && x[b][w] <= upper_bounds[b][w]);   
            i++;
        }
    }
}

static inline int top1(const float output[BATCH][OUTPUT_SIZE])
{
    int top = 0;
    for(size_t b = 0; b < BATCH; b++)
    {
        for (size_t o = 0; o < OUTPUT_SIZE; o++)
        {
            if(output[b][o] <= output[b][top])
            {
                continue;
            }
            top = (int) o;
        }
    }
    return top;
}

static inline void epsilon(
    const float output_original[BATCH][OUTPUT_SIZE],
    const float output_quantized[BATCH][OUTPUT_SIZE],
    float output_diff[BATCH][OUTPUT_SIZE]
){
    for(size_t b = 0; b < BATCH; b++)
    {
        for (size_t O = 0; O < OUTPUT_SIZE; O++)
        {
            output_diff[b][O] = output_original[b][O] - output_quantized[b][O];
            if(output_diff[b][O] >= 0)
            {
                continue;
            }
            output_diff[b][O] *= -1.0; 
        }
    }
}

static inline void check_top(const float output_original[BATCH][OUTPUT_SIZE], const float output_quantized[BATCH][OUTPUT_SIZE])
{
    int original_prediction = top1(output_original);
	int quantized_prediction = top1(output_quantized);

    int property_holds = (original_prediction==quantized_prediction);
    __ESBMC_assert(property_holds, "Networks not equivalent.");
}

static inline void check_epsilon(const float output_original[BATCH][OUTPUT_SIZE], const float output_quantized[BATCH][OUTPUT_SIZE])
{
    float output_diff[BATCH][OUTPUT_SIZE];
    
    // Get output diff
    epsilon(output_original, output_quantized, output_diff);

    int property_holds = 1;
    for(size_t O = 0; O < OUTPUT_SIZE; O++)
    {
        if (output_diff[0][O] <= EPSILON)
        {
            continue;
        }

        property_holds = 0;
        break;
    }

    __ESBMC_assert(property_holds, "Networks not equivalent.");
}

int main()
{

    // Define input and output vectors
    float input[BATCH*WIDTH];
    float x[BATCH][WIDTH];
    float original_output[BATCH][OUTPUT_SIZE];
    float quantized_output[BATCH][OUTPUT_SIZE];


    // Init symbolic input vector
    init_symbolic_input(input);

    // Add input assumptions
    add_input_assumptions(input, x);

    // Call networks
    original(x, original_output);
    quantized(x, quantized_output);

    if(EQUIVALENCE == 0)
    {
        check_top(original_output, quantized_output);
    } else {
        check_epsilon(original_output, quantized_output);
    }
}

